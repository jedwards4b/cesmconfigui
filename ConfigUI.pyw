#!/usr/bin/env python
# -*- coding: utf-8 -*-

#  This program requires python (2 or 3) with the BeautifulSoup package to run

"""
This is a program for reading and editing XML files
Current attributes and tag contents can be edited; no new attributes or tags can be created.
This program was written specifically for wide char config files generated by MS .net
But should work with anything.

Type in a directory or browse to one using the "..." button.
A list of files matching the extensions in the options file will be made and populate the dropdown

Selecting a file will load it.

Save a file by pressing the "Save" button or "Ctrl-s"
The file is renamed with a current timestamp, and the new file is written in it's place.
"""

import tkinter as tk
from tkinter import ttk
from tkinter.filedialog import askdirectory
from tkinter.messagebox import showerror
basestring = str

import re
import codecs
import os
from functools import partial
import bs4
import json
import time
import sys
import traceback
import copy

__version__ = (0,0,1)
debug = True

# load global options dictionary
opt_fn = "reader_options.json"

# default options
opt = {
    # Todo: make this general
    'dir': "/glade/u/home/jedwards/sandboxes/cesm2_x_alpha/ccs_config/machines", # last seen directory
    'geometry': "350x550",
    'save_position': True, # save the geometry and position of the window and restore on next load
    'formats': 'config_machines.xml', # extensions of files to be listed; space delimited
    'entrybox_width': 25,  # width of the entry boxes
    'output_encoding': 'autodetect', # any valid encoding ('utf-8', 'utf-16le', etc) or autodetect.
    'backup_ext': '.bak', # extension of backed up files. Use something not in 'formats' to prevent backups from showing in the dropdown list.
    }

try:
    with open(opt_fn) as f:
        opt.update(json.load(f))
except Exception as e:
    print("default options used due to", e)

class FilePicker(tk.Frame):
    def __init__(self, master, command=None):
        tk.Frame.__init__(self, master)
        self.command = command

        hlm = tk.Frame(self)
        hlm.pack(fill=tk.X, expand=tk.TRUE)
        self.fold = AutoSelectEntry(hlm, command=self.browse)
        self.fold.pack(side=tk.LEFT, fill=tk.X, expand=tk.TRUE)
        btn = ttk.Button(hlm, text="...", width=3, command=self.browse)
        btn.pack(side=tk.LEFT)

        hlm = tk.Frame(self)
        hlm.pack(fill=tk.X, expand=tk.TRUE)
        self.file = tk.StringVar(self)
        self.file.set("Select a File")
        self.files = ttk.OptionMenu(hlm, self.file)
        self.files.pack(side=tk.LEFT, fill=tk.X, expand=True)

        btn = ttk.Button(hlm, text="Save", command=master.save)
        btn.pack(side=tk.LEFT)

    def update_options(self, options):
        self.files['menu'].delete(0, tk.END)
        for option in options:
            self.files['menu'].add_command(label=option, command=partial(self.run_command, option))
        self.file.set("Select a File")

    def run_command(self, fn):
        try:
            if self.command:
                self.command(os.path.join(self.fold.get(), fn))
            if debug:
                print(f"filename is {fn}")
            self.file.set(fn)
        except Exception as e:
            if debug:
                traceback.print_exc()
            showerror("File Load Error", "%s is not a valid XML file.\n%s"%(fn, e))
            if debug: raise

    def browse(self, dir=None):
        if dir is None:
            dir = askdirectory(initialdir=opt.get('dir'))
        if dir: # check for user cancelled
            result = self.load_dir(dir)
            if hasattr(self.master, 'status'):
                self.master.status.set(result)

    def load_dir(self, dir):
        try:
            fns = os.listdir(dir)
        except Exception as e:
            print("could not load folder:", e)
            return "invalid folder"
        opt['dir'] = dir
        self.fold.set(dir)
        file_types = [x.strip() for x in opt['formats'].split()]
        dir = [fn for fn in fns if any(fn.endswith(x) for x in file_types)]
        self.update_options(dir)
        return "{} files found".format(len(dir))

    def load_path(self, path):
        dir, fn = os.path.split(path)
        self.load_dir(dir)
        self.run_command(fn)


class VerticalScrolledFrame:
	"""
	A vertically scrolled Frame that can be treated like any other Frame
	ie it needs a master and layout and it can be a master.
	keyword arguments are passed to the underlying Canvas (eg width, height)
	"""
	def __init__(self, master, **kwargs):
		self.outer = tk.Frame(master)

		self.vsb = tk.Scrollbar(self.outer, orient=tk.VERTICAL)
		self.vsb.pack(fill=tk.Y, side=tk.RIGHT)
		self.canvas = tk.Canvas(self.outer, highlightthickness=0, **kwargs)
		self.canvas.pack(side=tk.LEFT, fill=tk.BOTH, expand=True)
		self.canvas['yscrollcommand'] = self.vsb.set
		self.canvas.bind("<Enter>", self._bind_mouse)
		self.canvas.bind("<Leave>", self._unbind_mouse)
		self.vsb['command'] = self.canvas.yview

		self.inner = tk.Frame(self.canvas)
		# pack the inner Frame into the Canvas with the topleft corner 4 pixels offset
		self.canvas.create_window(4, 4, window=self.inner, anchor='nw')
		self.inner.bind("<Configure>", self._on_frame_configure)

		self.outer_attr = set(dir(tk.Widget))
		self.frames = (self.inner, self.outer)

	def __getattr__(self, item):
		"""geometry attributes etc (eg pack, destroy, tkraise) are passed on to self.outer
		all other attributes (_w, children, etc) are passed to self.inner"""
		return getattr(self.frames[item in self.outer_attr], item)

	def _on_frame_configure(self, event=None):
		self.canvas.configure(scrollregion=self.canvas.bbox("all"))

	def _bind_mouse(self, event=None):
		"""mouse event bind does not work, so this hack allows the use of bind_all
		Linux uses Buttons, Windows/Mac uses MouseWheel"""
		for ev in ("<Button-4>", "<Button-5>", "<MouseWheel>"):
			self.canvas.bind_all(ev, self._on_mousewheel)

	def _unbind_mouse(self, event=None):
		for ev in ("<Button-4>", "<Button-5>", "<MouseWheel>"):
			self.canvas.unbind_all(ev)

	def _on_mousewheel(self, event):
		"""Linux uses event.num; Windows / Mac uses event.delta"""
		if event.num == 4 or event.delta == 120:
			self.canvas.yview_scroll(-1, "units" )
		elif event.num == 5 or event.delta == -120:
			self.canvas.yview_scroll(1, "units" )


class AutoSelectEntry(ttk.Entry):
    elements = []

    def __init__(self, master, command=None, **kwargs):
        """Entry widget that auto selects when focused
        command is a function to execute on value change"""
        ttk.Entry.__init__(self, master, **kwargs)
        self.command = command
        self.old_value = None
        self.elements.append(self)
        self.dirty = False

        self.bind('<FocusIn>', self.select_all)
        self.bind('<Return>', self.input_change)
        self.bind('<FocusOut>', self.input_change)

    def select_all(self, event=None):
        self.selection_range(0, tk.END)

    def input_change(self, event=None, value=None):
        if value is None:
            value = self.get()
        if self.command is not None:
            if value == self.old_value:
                return # check for a change; prevent command trigger when just tabbing through
            self.dirty = True
            self.old_value = value
            self.command(value)
        self.select_all()

    def set(self, text=None, run=False):
        if text is None:
            text = ""
        if len(text) > 500:
            text = "<too long to display>"
        self.delete(0, tk.END)
        self.insert(0, text)
        self.old_value = text
        if run:
            self.input_change(text)

class GUI(tk.Frame):
    def __init__(self, master):
        tk.Frame.__init__(self, master)

        self.fn = None
        self.bs = None
        master.title("CIME Configure and XML File Editor")
        master.geometry(opt.get('geometry'))
        master.protocol('WM_DELETE_WINDOW', self._quit)

        self.master = master
        self.top = FilePicker(self, command=self.load_file)
        self.top.pack(fill=tk.X)

        self.top.load_dir(opt.get('dir') or os.getcwd())

        self.data_frame = tk.Frame(self)
        self.data_frame.pack(fill=tk.BOTH, expand=True)

        self.status = tk.StringVar(self, "Version: "+".".join(map(str,__version__)))
        lbl = ttk.Label(self, textvariable=self.status)
        lbl.pack(fill=tk.X)

    def _quit(self):
        if opt.get('save_position'):
            opt['geometry'] = self.master.geometry()
        else:
            # strip the position information; keep only the size information
            opt['geometry'] = self.master.geometry().split('+')[0]
        self.master.destroy()

    def load_file(self, fn):
        print('loading', fn)
        self.fn = os.path.normpath(fn)
        AutoSelectEntry.elements = []
        # "rb" mode is python 2 and 3 compatibe; BS handles the unicode conversion.
        with open(fn, 'rb') as f:
            self.bs = bs4.BeautifulSoup(f, 'xml')
        elements, comments = [], []
        for e in self.bs.contents:
            if istag(e):
                elements.append(e)
            elif isinstance(e, basestring):
                comments.append(e)
            else:
                print("WARNING: unidentified elements found:", e)
        if len(elements) > 1:
            print("WARNING: %s root elements found; one expected")
        assert elements, "No XML data found"

        start = elements[0]
        if start.name == "config_machines":
            self.xmlmachines = XMLMachines(self, start)            
        else:
            print(f"start.name {start.name} is not (yet) supported")
            raise
        

        self.status.set("File backed up and saved.")

class RadiobuttonMenu:
    def __init__(self, master, bs, row, column, options):
        mb = tk.Menubutton(master, width=opt['entrybox_width'], text=bs.name+": "+options[0])
        mb.menu = tk.Menu(mb, tearoff=0)
        mb['menu'] = mb.menu
        if debug: print(f"options are {options}")
        self.val = tk.IntVar()
        self.options = options
        self.bs = bs
        self.mb = mb
        cnt = 0
        for text in options:
            mb.menu.add_radiobutton(label=text, variable=self.val, value=cnt, command=self.selected)
            cnt = cnt + 1
        mb.grid(row=row, column=column, sticky='e')
    
    def selected(self):
        value = self.options[self.val.get()]
        if debug: print(f"In RadiobuttonMenu selection {self.options[self.val.get()]}")
        self.mb.configure(text=self.bs.name + ": " + value)
        self.bs.string = value

        
class XMLMachineEditor(tk.Frame):
    def __init__(self, master, bs):
        tk.Frame.__init__(self, master.master)
        master.bind("<Control - S>", self.save)
        master.bind("<Control - s>", self.save)
        self.master = master
        self.mb = None
        self.data_frame = tk.Frame(self)
        self.display = VerticalScrolledFrame(self.data_frame)
        lblframe = self.make_label_frame(master, bs)
        self.define_buttons(master)
        self.display.pack(fill=tk.BOTH, expand=True)
        self.data_frame.pack(fill=tk.BOTH, expand=True)
        lblframe.pack()
                
    def make(self, frame, bs):
        children = list(filter(istag, bs.children))
#        if debug: print(f"children = {children}")
        idx = 0
        num_attributes = len(bs.attrs)
        num_text = 0 if bs.string is None else 1
#        if debug:
#            print("{}: {} attributes; {} text; {} grandchildren".format(bs.name, num_attributes, num_text, len(children)))

        # list out the attributes, then text, then grandchildren.
        for attr, value in bs.attrs.items():
            # attribute entry
            
            idx = self.make_entry(frame, idx, attr, value.strip(), partial(self.change_attr, bs, attr))
        if bs.string is not None:
            # text entry
            idx = self.make_entry(frame, idx, "", bs.text.strip(), partial(self.change_attr, bs, None))
        for child in children:
            num_children = len(child.findChildren()) + len(child.attrs)
            if num_children == 0 and child.string is not None:
                # special case of only 1 text - making entry
                if debug: print(f"name = {child.name} string = {child.string.strip()}")
                if child.name in ("OS", "BATCH_SYSTEM"):
                    if child.name == "OS":
                        options = ["LINUX", "CNL"]
                    elif child.name == "BATCH_SYSTEM":
                        options = ["pbs", "slurm", "cobalt", "moab", "lsf", "none"]
                    osselect = RadiobuttonMenu(frame, bs=child, row=idx, column=1, options=options)
                    idx += 1
                elif child.name in ("GMAKE_J", "MAX_TASKS_PER_NODE", "MAX_MPITASKS_PER_NODE"):
                    lbl = tk.Label(frame, text=child.name)
                    lbl.grid(row=idx, column=0, sticky='ew')
                    my_var = tk.StringVar()
                    my_var.set(child.string.strip())
                    if debug: print(f"spinbox {child.name} value {my_var.get()}")
                    sb = ttk.Spinbox(frame, from_=1, to=256, width=opt['entrybox_width'], textvariable=my_var)
                    sb.grid(row=idx, column=1, sticky='e')
                    idx=idx+1
                else:
                    idx = self.make_entry(frame, idx, child.name, child.string.strip(), partial(self.change_attr, child, None))
            elif num_children > 0:
                # child has one attribute or one grandchild; make new frame
                h = self.make_label_frame(frame, child)
                h.grid(row=idx, column=0, columnspan=2, sticky='ew', padx=10, pady=10)
                idx += 1
                # else: tag has no children and no text; ignore

    @staticmethod
    def make_entry(master, row, name, value, command):
#        if debug:
#            print(f"name {name} value {value}")
        lbl = tk.Label(master, text=name, anchor='e')
        lbl.grid(row=row, column=0, sticky='ew')
        ent = AutoSelectEntry(master, width=opt['entrybox_width'], command=command)
        ent.set(value)
        ent.grid(row=row, column=1, sticky='e')
        return row + 1

    def make_label_frame(self, master, bs):
        frame = ttk.LabelFrame(master, text=bs.name)
        hlm = tk.Frame(frame)
        hlm.columnconfigure(0, weight=1)
        self.make(hlm, bs)
        hlm.pack(side=tk.RIGHT)
        return frame

    def dirty_status(self):
        changes = "{} unsaved changes".format(sum(x.dirty for x in AutoSelectEntry.elements))
        print(changes)
        self.status.set(changes)

    def change_attr(self, bs, attr, new_text):
        if attr is None:
            bs.string = new_text
        else:
            bs[attr] = new_text
        self.dirty_status()

    def define_buttons(self, master):
        frame = ttk.Frame(master)
        frame.columnconfigure(0, weight=1)
        save = ttk.Button(frame, text="Save", command=lambda: self.exitwin('save'))
        cancel = ttk.Button(frame, text="Cancel", command=lambda: self.exitwin('cancel'))
        frame.pack(side=tk.BOTTOM)
        save.grid(row=0,column=0)
        cancel.grid(row=0,column=1)
        
    def save(self, event=None):
        print("Saving data")

        # trigger current variable if needed
        current = self.focus_get()
        if hasattr(current, 'input_change'):
            current.input_change()

        try:
            self.save_core()
        except Exception as e:
            showerror("Save Error", "Could not save file.\n"+str(e))
            if debug: raise

    def save_core(self):
        if self.fn is None:
            print("cannot save - no file loaded")
            self.status.set("cannot save - no file loaded")
            return
        name, ext = os.path.splitext(self.fn)
        bkup_name = name + time.strftime("_%Y-%m-%d_%H-%M-%S") + ext + opt['backup_ext']
        os.rename(self.fn, bkup_name)
        print(self.fn, "backed up to", bkup_name)

        # whatever weirdness Andrew uses encodes in utf-16 and with windows-style line endings ... so I will too.
        # but beautifulsoup insists on normal output, so have to change it first.
        encoding = opt['output_encoding']
        if encoding == 'autodetect':
            encoding = self.bs.original_encoding
            print(encoding, "encoding autodetected")
            if encoding.startswith('utf-16'): # remove the "le" (MS BOM)
                encoding = 'utf-16'

#        data = self.bs.prettify()
#
#        data = data.replace('\n', '\r\n')  # Windows ... (sigh)
#        data = data.replace('utf-8', encoding, 1)  # BS insists on utf8 output from prettify

        with codecs.open(self.fn, 'w', encoding) as f:
            f.write(data)

        for element in AutoSelectEntry.elements:
            element.dirty = False

    def exitwin(self, method):
        if debug: print(f"exitwin: {method}")
        if method == "save":
            self.save()
        self.master.destroy()
        
        

class XMLMachines(tk.Frame):
    def __init__(self, master, bs):
        tk.Frame.__init__(self, master)
        master.title("CIME Configure and XML File Editor")
        master.geometry(opt.get('geometry'))
        master.protocol('WM_DELETE_WINDOW', self._quit)

        master.bind("<Control - S>", self.save)
        master.bind("<Control - s>", self.save)
        self.top = FilePicker(self, command=self.load_file)
        self.top.pack(fill=tk.X)

        self.top.load_dir(opt.get('dir') or os.getcwd())

        self.root = master
        self.bsmachines = {}
        scrollbar = ttk.Scrollbar(self.root)
        self.display = ttk.Treeview(self.root, yscrollcommand=scrollbar.set, show="tree", selectmode="browse")
        scrollbar.configure(command=self.display.yview)
        scrollbar.pack(side="right", fill="y")
        self.display.pack(expand=True, fill=tk.BOTH)

        self.define_buttons()

        if debug: print("Loaded {} elements".format(len(AutoSelectEntry.elements)))
        self._frame = ttk.LabelFrame(master, text="Machine Selection")
        hlm = tk.Frame(self._frame)
        hlm.columnconfigure(0, weight=1)
        self.make(hlm, bs)
        hlm.pack(side=tk.RIGHT)

    def new_machine(self):
        """ Copy the example machine description into a new machine name """
        
        if debug: print("new machine called")

    def edit_machine(self):
        """ Edit the selected machine description """
        machine = self.display.item(self.display.selection()[0], option="text")
        if debug: print(f"edit machine called, machine is {machine}")
        ew = tk.Toplevel(self)
        ew.title("Machine XML Editor")
        XMLMachineEditor(ew, self.bsmachines[machine])

    def copy_machine(self):
        """ Copy the given machine description into a new machnine name """
        
        machine = self.display.item(self.display.selection()[0], option="text")
        if debug: print(f"copy machine called, machine is {machine}")
        new_machine_name = tk.simpledialog.askstring(title="Copy", prompt="Enter the new machine name:")
        if debug: print(f"new_machine is {new_machine_name}")
        if new_machine_name in self.bsmachines:
            print(f"ERROR: match to name in list")
        elif new_machine_name:
            self.bsmachines[new_machine_name] = copy.copy(self.bsmachines[machine])
            self.bsmachines[new_machine_name].attrs["MACH"] = new_machine_name
            self.bsmachines[machine].find_parent().append(self.bsmachines[new_machine_name])
            self.display.insert("", "end", text=new_machine_name)
            
    def delete_machine(self):
        """ Delete the given machine - eventually this should apply to all cesm config xml files """
        machine = self.display.item(self.display.selection()[0], option="text")
        if debug: print(f"delete machine called, machine is {machine}")
        
        self.display.delete(self.display.focus())
        self.bsmachines[machine].decompose()
        del self.bsmachines[machine]
        
    def define_buttons(self):
        frame = ttk.Frame(self.root)
        frame.columnconfigure(0, weight=1)
        newmach = ttk.Button(frame, text="New", command=self.new_machine)
        editmach = ttk.Button(frame, text="Edit", command=self.edit_machine)
        copymach = ttk.Button(frame, text="Copy", command=self.copy_machine)
        deletemach = ttk.Button(frame, text="Delete", command=self.delete_machine)
        frame.pack(side=tk.BOTTOM)
        newmach.grid(row=0,column=0)
        editmach.grid(row=0,column=1)
        copymach.grid(row=0,column=2)
        deletemach.grid(row=0,column=3)
        

        
    def make_label_frame(self, master, bs):
        frame = ttk.LabelFrame(master, text="Machine Selection")
        hlm = tk.Frame(frame)
        hlm.columnconfigure(0, weight=1)
        self.make(hlm, bs)
        hlm.pack(side=tk.RIGHT)
        return frame

    def make(self, frame, bs):
        children = list(filter(istag, bs.children))
        idx = 0
        num_attributes = len(bs.attrs)
        num_text = 0 if bs.string is None else 1
        if debug:
            print("{}: {} attributes; {} text; {} grandchildren".format(bs.name, num_attributes, num_text, len(children)))
        
        lbl = tk.Label(self.root, text="Supported Machines")
#        row = 0
#        lbl.grid(row=row, column=0, sticky='ew')
        lbl.pack(side="top",fill="y")
#        listbox.pack(side="left", fill="both", expand=True)
        # list out the attributes, then text, then grandchildren.
        children = list(filter(istag, bs.children))
        for child in children:
            # attribute entry
            if child.name == "machine":
                name = child.attrs["MACH"]
                self.display.insert("", "end", text=name)
                self.bsmachines[name] = child

    def save(self, event=None):
        print("Saving data")

        # trigger current variable if needed
        current = self.focus_get()
        if hasattr(current, 'input_change'):
            current.input_change()

        try:
            self.save_core()
        except Exception as e:
            showerror("Save Error", "Could not save file.\n"+str(e))
            if debug: raise

    def save_core(self):
        if self.fn is None:
            print("cannot save - no file loaded")
            self.status.set("cannot save - no file loaded")
            return
        name, ext = os.path.splitext(self.fn)
        bkup_name = name + time.strftime("_%Y-%m-%d_%H-%M-%S") + ext + opt['backup_ext']
        os.rename(self.fn, bkup_name)
        print(self.fn, "backed up to", bkup_name)

        # whatever weirdness Andrew uses encodes in utf-16 and with windows-style line endings ... so I will too.
        # but beautifulsoup insists on normal output, so have to change it first.
        encoding = opt['output_encoding']
        if encoding == 'autodetect':
            encoding = self.bs.original_encoding
            print(encoding, "encoding autodetected")
            if encoding.startswith('utf-16'): # remove the "le" (MS BOM)
                encoding = 'utf-16'

#        data = self.bs.prettify()
#
#        data = data.replace('\n', '\r\n')  # Windows ... (sigh)
#        data = data.replace('utf-8', encoding, 1)  # BS insists on utf8 output from prettify

        with codecs.open(self.fn, 'w', encoding) as f:
            f.write(data)

        for element in AutoSelectEntry.elements:
            element.dirty = False

        
def istag(test):
    return isinstance(test, bs4.Tag)

def main():
    root = tk.Tk()
    window = XMLMachines(root)
    window.pack(fill=tk.BOTH, expand=True)
    if len(sys.argv) > 1:
        window.top.load_path(" ".join(sys.argv[1:]))
    root.mainloop()
    with open(opt_fn, 'w') as f:
        json.dump(opt, f, indent=2)

if __name__ == "__main__":
    try:
        main()
    except Exception as e:
        showerror("Fatal error!", "CIME Editor crashed.\n\n"+str(e))
        raise
